---
Created: 2025-10-08T20:04:00
Links:
  - "[[C]]"
  - "[[The C programming language]]"
  - "[[Bit]]"
tags:
  - abstract
Completed: false
---

# Difference between &, | and &&, ||

  

### ğŸ§  Main Difference:

  

| Operator | Type    | Works With          | Name        | Special Feature           |
| -------- | ------- | ------------------- | ----------- | ------------------------- |
| `&`      | Bitwise | Numbers             | Bitwise AND | Compares each bit         |
| `\|`     | Bitwise | Numbers             | Bitwise OR  | Compares each bit         |
| `&&`     | Logical | Boolean expressions | Logical AND | Short-circuit evaluation` |
| \|\|     | Logical | Boolean expressions | Logical OR  | Boolean expressions       |

  

---

  

### ğŸ”§ Details:

  

### `&` and `|` â€” **Bitwise Operators**

  

Operate **bit-by-bit** on integers.

  

```c

int a = 6; Â  // 0b0110

int b = 3; Â  // 0b0011


int c = a & b; // 0b0010 = 2

int d = a | b; // 0b0111 = 7

```

  

### `&&` and `||` â€” **Logical Operators**

  

Work with expressions that evaluate to `true` (non-zero) or `false` (zero). They return `0` or `1`.

  

```c

int a = 1;

int b = 0;

  

int c = a && b; // 0 (since b == 0)

int d = a || b; // 1 (since a == 1)

```

  

---

  

### âš¡ Special Feature of `&&` and `||`: Short-circuiting

  

```c

if (a != 0 && (10 / a) > 1) { ... }

```

  

If `a == 0`, then `10 / a` **wonâ€™t be evaluated**, avoiding division by zero.

  

**This only happens with `&&` and `||`, not with `&` or `|`.**

  

---

  

### ğŸ§ª Difference Example:

  

```c

int a = 0;

int b = 5;

  

if (a && (b++ > 0)) { } // b is not incremented because a == 0

if (a & (b++ > 0)) Â { } // b is incremented, even though a == 0

```

  

---

  

### âœ… Summary:

  
| Operator | Type    | Applies To          | Behavior                                      |
|----------|---------|---------------------|-----------------------------------------------|
| &        | Bitwise | Integers            | Compares each bit                             |
| \|       | Bitwise | Integers            | Compares each bit                             |
| &&       | Logical | Boolean expressions | Returns `1` or `0`, short-circuits            |
| \|\|     | Logical | Boolean expressions | Returns `1` or `0`, short-circuits            |
  

# Left shift << and Right shift >>

  

### ğŸ“Œ What They Do:

  

| Operator | Name        | Action                                                              |
|----------|-------------|---------------------------------------------------------------------|
| <<       | Left shift  | Shifts bits to the left, fills zeros on the right                   |
| >>       | Right shift | Shifts bits to the right, fills with zeros or sign bit (depends on type) |

  

---

  

### ğŸ§  Principle:

  

```c

a << n

```

  

Shifts all bits of `a` to the **left by `n` positions**

  

ğŸ‘‰ Equivalent to multiplying by `2â¿`

  

```c

a >> n

```

  

Shifts all bits of `a` to the **right by `n` positions**

  

ğŸ‘‰ Equivalent to dividing by `2â¿` (if `a` is unsigned)

  

---

  

### ğŸ”¢ Example:

  

```c

unsigned int a = 5; Â  Â  Â // 0b00000101

  

int x = a << 1; Â  Â  Â  Â  Â // 0b00001010 = 10

int y = a >> 1; Â  Â  Â  Â  Â // 0b00000010 = 2

```

  

---

  

### ğŸ§¨ Important Notes:

  

- `<<` **always** adds zeros on the right.

- `>>` depends on the type of `a`:

Â  Â  - If `a` is **unsigned**, `>>` fills with zeros on the left (**logical shift**).

Â  Â  - If `a` is **signed**, behavior depends on the compiler:

Â  Â  Â  Â  - It may fill with zeros (**logical shift**),

Â  Â  Â  Â  - Or replicate the sign bit (**arithmetic shift**, preserves the sign).

  

---

  

### ğŸ‘€ Example with a Negative Number:

  

```c

int a = -4; Â  Â  Â  Â  // typically: 0b11111100 (in 8-bit representation)

int b = a >> 1; Â  Â  // may become 0b11111110 (-2), preserving the sign

```

  

âš ï¸ Behavior may vary between platforms!

  

**Avoid using `>>` with negative numbers if portability is important.**

  

---

  

### ğŸ›  Use Cases:

  

- Fast multiplication/division by `2â¿`

- Bit manipulation (e.g., masks, flags)

- Codecs, graphics, cryptography, low-level optimizations

## Exercise 2-6

```c
#include <stdio.h>

unsigned int setbits(unsigned int x, int p, int n, unsigned int y);
unsigned int create_clearing_mask(int p, int n);
unsigned int prepare_y_bits(int p, int n, unsigned int y);

int main() {
  unsigned int x = 181; // 10110101
  int p = 4;
  int n = 3;
  unsigned int y = 230; // 11100110

  printf("Original x: %u (10110101)\n", x);
  printf("Original y: %u (11100110)\n", y);

  unsigned int result = setbits(x, p, n, y);

  // Expected result: 185 (10111001)
  printf("  Result:   %u (10111001)\n", result);

  return 0;
}

/**
 * @brief Replaces n bits in x, starting from position p, with the rightmost n
 * bits of y.
 * @param x The original number to modify.
 * @param p The starting position (from right, 0-indexed) for the replacement.
 * @param n The number of bits to replace.
 * @param y The source number from which to take the bits.
 * @return The modified number.
 */
unsigned int setbits(unsigned int x, int p, int n, unsigned int y) {
  unsigned int clearing_mask = create_clearing_mask(p, n);
  unsigned int cleared_x = x & clearing_mask;
  unsigned int y_segment = prepare_y_bits(p, n, y);

  // Since the target area in cleared_x is all zeros, the OR operation acts as
  // an insertion.
  return cleared_x | y_segment;
}

/**
 * @brief Creates a mask to clear n bits starting at position p.
 * @return A mask with zeros in the target n-bit field and ones everywhere else.
 */
unsigned int create_clearing_mask(int p, int n) {
  // This is a classic trick to generate n ones: `1 << n` creates `10...0`,
  // and subtracting 1 flips all the lower bits to `011...1`.
  unsigned int n_ones = (1 << n) - 1;

  // To position a block of n bits starting at p, its rightmost edge must be
  // at position (p - n + 1). This is the required shift amount.
  int shift_amount = p - n + 1;
  unsigned int positioned_ones = n_ones << shift_amount;

  return ~positioned_ones;
}

/**
 * @brief Extracts the rightmost n bits from y and shifts them to align with
 * position p.
 * @return The bits from y, ready for insertion.
 */
unsigned int prepare_y_bits(int p, int n, unsigned int y) {
  unsigned int extraction_mask = (1 << n) - 1;
  unsigned int extracted_bits = y & extraction_mask;
  int shift_amount = p - n + 1;

  return extracted_bits << shift_amount;
}
```

## Exercise 2-7

```C
#include <stdio.h>

unsigned int invert(unsigned int x, int p, int n);
unsigned int get_field_mask(int p, int n);

int main() {
  // Test case: invert 3 bits starting at position 4.
  unsigned int x = 181; // 10110101
  int p = 4;
  int n = 3;

  // Original segment (bits 4,3,2): 101
  // Expected inverted segment: 010
  // Expected result: 10101001 (169)

  printf("Original: %u (10110101)\n", x);

  unsigned int result = invert(x, p, n);

  printf("Inverted: %u (10101001)\n", result);

  return 0;
}

/**
 * @brief Inverts n bits in x, starting at position p.
 * @param x The original number.
 * @param p The position of the field (from right, 0-indexed).
 * @param n The width of the field in bits.
 * @return The number with the bit-field inverted.
 */
unsigned int invert(unsigned int x, int p, int n) {
  // Create a mask with 1s at the positions to be inverted (e.g., 0011100).
  unsigned int field_mask = get_field_mask(p, n);

  // The XOR (^) operator inverts the bits in x where the mask bit is 1
  // and leaves all other bits unchanged. This is the most efficient way.
  return x ^ field_mask;
}

/**
 * @brief Creates a mask with n ones, starting at position p.
 * @return A mask in the form of ...000111000...
 */
unsigned int get_field_mask(int p, int n) {
  // Create n ones in the least significant bits (e.g., 00000111).
  unsigned int n_ones = (1 << n) - 1;

  // Shift the ones to the correct position.
  int shift_amount = p - n + 1;

  return n_ones << shift_amount;
}
```

## Exercise 2-8

```c
#include <limits.h>
#include <stdio.h>

unsigned int rightrot(unsigned int x, int n);

int main() {
  unsigned int num = 211; // 11010011
  int rotate_by = 3;

  // Expected result after rotating 11010011 right by 3: 01111010 (122)
  unsigned int result = rightrot(num, rotate_by);

  printf("Original: %u (11010011)\n", num);
  printf("Rotated:  %u (01111010)\n", result);

  return 0;
}

/**
 * @brief Rotates an unsigned integer x to the right by n bit positions.
 * @param x The unsigned integer to rotate.
 * @param n The number of positions to rotate right.
 * @return The rotated value of x.
 */
unsigned int rightrot(unsigned int x, int n) {
  // Determine the total number of bits in the type to make the code portable.
  const int WORD_SIZE = sizeof(unsigned int) * CHAR_BIT;

  // Handle cases where n is larger than the word size.
  n = n % WORD_SIZE;

  // 1. Isolate the n rightmost bits that will become the new leftmost bits.
  unsigned int tail_mask = (1 << n) - 1;
  unsigned int tail = x & tail_mask;

  // 2. Shift the main body of the number to the right.
  unsigned int shifted_x = x >> n;

  // 3. Reposition the isolated tail to the far left.
  unsigned int positioned_tail = tail << (WORD_SIZE - n);

  // 4. Combine the shifted body with the repositioned tail.
  return shifted_x | positioned_tail;
}
```