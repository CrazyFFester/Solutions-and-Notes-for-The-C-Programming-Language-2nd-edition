---
Created: 2025-10-08T20:04:00
Links:
  - "[[C]]"
  - "[[The C programming language]]"
  - "[[Bit]]"
tags:
  - abstract
Completed: false
---

# Difference between &, | and &&, ||

  

### ğŸ§  Main Difference:

  

| Operator | Type    | Works With          | Name        | Special Feature           |
| -------- | ------- | ------------------- | ----------- | ------------------------- |
| `&`      | Bitwise | Numbers             | Bitwise AND | Compares each bit         |
| `\|`     | Bitwise | Numbers             | Bitwise OR  | Compares each bit         |
| `&&`     | Logical | Boolean expressions | Logical AND | Short-circuit evaluation` |
| \|\|     | Logical | Boolean expressions | Logical OR  | Boolean expressions       |

  

---

  

### ğŸ”§ Details:

  

### `&` and `|` â€” **Bitwise Operators**

  

Operate **bit-by-bit** on integers.

  

```c

int a = 6; Â  // 0b0110

int b = 3; Â  // 0b0011


int c = a & b; // 0b0010 = 2

int d = a | b; // 0b0111 = 7

```

  

### `&&` and `||` â€” **Logical Operators**

  

Work with expressions that evaluate to `true` (non-zero) or `false` (zero). They return `0` or `1`.

  

```c

int a = 1;

int b = 0;

  

int c = a && b; // 0 (since b == 0)

int d = a || b; // 1 (since a == 1)

```

  

---

  

### âš¡ Special Feature of `&&` and `||`: Short-circuiting

  

```c

if (a != 0 && (10 / a) > 1) { ... }

```

  

If `a == 0`, then `10 / a` **wonâ€™t be evaluated**, avoiding division by zero.

  

**This only happens with `&&` and `||`, not with `&` or `|`.**

  

---

  

### ğŸ§ª Difference Example:

  

```c

int a = 0;

int b = 5;

  

if (a && (b++ > 0)) { } // b is not incremented because a == 0

if (a & (b++ > 0)) Â { } // b is incremented, even though a == 0

```

  

---

  

### âœ… Summary:

  
| Operator | Type    | Applies To          | Behavior                                      |
|----------|---------|---------------------|-----------------------------------------------|
| &        | Bitwise | Integers            | Compares each bit                             |
| \|       | Bitwise | Integers            | Compares each bit                             |
| &&       | Logical | Boolean expressions | Returns `1` or `0`, short-circuits            |
| \|\|     | Logical | Boolean expressions | Returns `1` or `0`, short-circuits            |
  

# Left shift << and Right shift >>

  

### ğŸ“Œ What They Do:

  

| Operator | Name        | Action                                                              |
|----------|-------------|---------------------------------------------------------------------|
| <<       | Left shift  | Shifts bits to the left, fills zeros on the right                   |
| >>       | Right shift | Shifts bits to the right, fills with zeros or sign bit (depends on type) |

  

---

  

### ğŸ§  Principle:

  

```c

a << n

```

  

Shifts all bits of `a` to the **left by `n` positions**

  

ğŸ‘‰ Equivalent to multiplying by `2â¿`

  

```c

a >> n

```

  

Shifts all bits of `a` to the **right by `n` positions**

  

ğŸ‘‰ Equivalent to dividing by `2â¿` (if `a` is unsigned)

  

---

  

### ğŸ”¢ Example:

  

```c

unsigned int a = 5; Â  Â  Â // 0b00000101

  

int x = a << 1; Â  Â  Â  Â  Â // 0b00001010 = 10

int y = a >> 1; Â  Â  Â  Â  Â // 0b00000010 = 2

```

  

---

  

### ğŸ§¨ Important Notes:

  

- `<<` **always** adds zeros on the right.

- `>>` depends on the type of `a`:

Â  Â  - If `a` is **unsigned**, `>>` fills with zeros on the left (**logical shift**).

Â  Â  - If `a` is **signed**, behavior depends on the compiler:

Â  Â  Â  Â  - It may fill with zeros (**logical shift**),

Â  Â  Â  Â  - Or replicate the sign bit (**arithmetic shift**, preserves the sign).

  

---

  

### ğŸ‘€ Example with a Negative Number:

  

```c

int a = -4; Â  Â  Â  Â  // typically: 0b11111100 (in 8-bit representation)

int b = a >> 1; Â  Â  // may become 0b11111110 (-2), preserving the sign

```

  

âš ï¸ Behavior may vary between platforms!

  

**Avoid using `>>` with negative numbers if portability is important.**

  

---

  

### ğŸ›  Use Cases:

  

- Fast multiplication/division by `2â¿`

- Bit manipulation (e.g., masks, flags)

- Codecs, graphics, cryptography, low-level optimizations

